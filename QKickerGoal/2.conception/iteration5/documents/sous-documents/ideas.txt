Spécification :
****************

Kernel :
	- Objet observable
	- Synchronise les différents engines
	- Délègue certaines tâches spécifiques à l'état courant.
	
GameState :
	-état courant
	-construit sa propre scène de jeu (en ajoutant les entités qu'il veut)
	-gère ses propres évènement (évènements qui ont été captés par sa propre scène), pour cela il
	doit garder une référence des entités qu'il a placé.
		-- Parmi les evenements gérées : gère les focus sur les entités graphiques ajoutés qu'il 
		a ajouté à sa scène.
		-- Chaque instance de GameState démarre un timer qui lui est propre, afin de pouvoir
		contrôler la fréquence à laquelle il traduit les evènements en actions appropriées.
		   Ex : le PlayingGameState a besoin d'une frequence qui permette la fuidité du jeu,
		   qui n'est pas forcément la même requise par l'état d'introduction, ou par l'état de
		   menu.
		
GraphicsEntity est définie par :
	-Un ensemble de pixel (QPixmap) qu'on peut rajouter à une scène 
	(QGraphcisItem) => QGraphicsPixmapItem,
	-un état du jeu peut rajouter à sa propre scène,
	-L'état courant l'agrège afin de l'ajouter à sa propre scène, et de pouvoir la modifier 
	après, selon les besoins du gameplay.
	
MovableEntity est définie par :
	-une entité graphique (héritage)
	-possédant une position modifiable sur la scène (agrège un QPointF)
	-doit connaître le terrain sur lequel il evolue (pour que sa capacité de se mouvoir respecte 
	les contraintes de l'endroit ou elle se meut).
	-possède une direction dans laquelle elle se meut.
	-possède une accélération, (lorsquon appuye sur une direction + Shift)
	-possède une décélération, (lorsqu'on relâche Shift).
	
Field :
	- entité graphique simple, sans rien de plus (optionnellement : rajouter Mode climat : Day or
	Night).
	- 

Avatar : 
	- MovableEntity,
	- Focusable, ie peut recevoir les evenments utilisateurs.
	* Comment un avatar set à quel position se placer sur le terrain :
		-- Si son équipe possède le coup d'envoi, alors il est très proche de la balle
			-- Si lui même possède le coup d'envoi, alors il est encore plus proche de la balle, 
			et possède le focus
		--Sinon il est très loin de  la ablle, dans sa motié de terrain.

Ball :
	- MovableEntity
	- A ball entity can move only when it's colliding with an avatar, that's mean that only an 
	avatar ca call this method
	- La balle ne connait que le terrain sur lequel elle evolue, elle ne connait pas l'avatar 
	qui la possede -> seul un avatar peut faire bouger la balle.
	
A priori, Ball et Avatar possèdent les mêmes propriétés de déplacement.

Team :
	-Strcuture composite
	-composée de 2 avatars et un goalkeeper
	-N'offre aucun servie, ce qui est logique puisqu'une équipe ne peut réaliser que ce que ses 
	composants (ir: ses avatars) réalisent
	--> Un objet team nous permet juste de regrouper les avatars dans une structure qui permettent
	d'y accéder rapidement.


Conception :
***********
Changes occurred in the conception :
-----------------------------------
* Impelemnting the GraphicsEntity as subclasse of QGraphicsItem, such that the GraphihcsScene has
got the list of entites (wich are QGItems) 
	to the purpose of getting their positions.

* Instantiating avatars in scene via current game state, as simply as possible.

* Attaching a slot on QApplication::exec() which call Kernel::notify() at ich user's event 
handled by the loop(in the old implementation 
	Kernel::notify() is called only when a state is changed, but we need this call everytime that
	the scene is changed, (ie after handling event by the scene).
	
	---> Nous avons connecté plutot le signal QGraphicsScene::changed(..) au slot 
	Kernel::notify() afin que chaque changement au niveau de la de scène 
		soit renseigné au noyau via sa méthode notify(), qui va mettre à jour les moteurs de jeu.
		 C'est ainsi que le moteur graphique peut suivre l'évolution de la scène et la dessiner.
		 Afin de définir Kernel::notify() comme étant un slot, nous devons transformer Kernel en 
		 une extension de QObject.

* Merging GraphicsEngine and GraphicsScene into one only GraphicsScene, which will inherit from 
QGraphicsScene, and agregate a QGraphicsView to draw and then visualize the scene.

Reimplement Subject::ad(Observer*) as Kernel::add(Engine*), which is legal because Kernel inherit
 from Subject, and Engine from Observer.

Les types STL ont été utilisé pour les classes génériques, pouvant servir pour un projet, et donc
 en utilisant une autre API.
Les types Qt (encapsulant les types primitifs) ont été utilisées pour les classes spécifiquement 
créées pour les besoins du jeu.

Une facon d'optimiser la rapidté de l'application est celle-ci : Les inline definitions  
(cf [Garetta Cpp]),
mais pour de raison de lisibilité du code, nous nous en sommes abstenus.

Les classes encapsulations Qt des types C++ primitifs ont étté utilisées telles quelle dans
l'implémenatation; nous n'avons pas voulu alourdir le code outre 
mesure en encapsulant les types que l'API a déjà encapsulé (qreal, QPoint, QSize, ...).

L'association GraphicsEntity-GraphicsScene permet de controler tout ce qu'un état rajoute dans sa
 propre scène. Un état ne peut ajouter à sa scène que des
instance de GraphicsEntity : il n'a pas accès direct aux classes de l'API -encapsulation de 
données oblige.

L'état en cours délégue la capture d'évnement à sa propre scène, qui utiliser uné réimplentation 
de la méthode Qt keyPressEvent() afin de capturer les evenements
qu'elle recoit, qui à son tour va renvoyer à l'état en cours l'evènement qu'elle a capturée, car 
seu le currentGameState sait quoi faire à propos de cet evt.
L'état courant du jeu doit encapsuler les considérations techniques (relevant seulement de l'API),
afin que les objets de la couche gameplay dépendent le moins possible de l'API, et le plus 
possible de la couche Engine.
Dans cet ordre d'idées, le GameState impélmente un timer (QTimer, pour ce fait il doit hériter
de QObject) afin de contrôler la fréquence à laquelle il désire interpréter les evènements que sa 
propre scène lui délègue.

Pixmaps des entités mouvantes :
	Un problème (sur le plan de la rapidité d'exécution du jeu) est le chargement des données, en 
	particulier celui des images servant de pixmpas	aux entités. Une solution a été d'attribuer, 
	à chaque sous-classe de MovableEntitie, un dictionnaire statique qui stocke, pour toutes les 
	instances de la sous-classe en question, les pixmaps suceptibles de représenter l'entité 
	mouvante au-cours du jeu.
	Le dictionnaire a été impélmenté avec un QMap, type Qt optimisé pour stocker des paires 
	<key,value> (ici les clés sont les noms des pixmaps, et les les valeurs
	des pointeurs vers les pixmaps à charger).
	Ainsi l'instanciation d'une sous-classe de MovableEntity chargeait, une fois pour toutes et 
	pour toutes les isntances futurs de la classe, les pixmaps utiles aux objets de la classe.
	Prenons un exemple : L'état PlayingGameState construit sa scène graphique, et y instancie un 
	premier avatar. Cet avatar va garnir une prmière fois le dictionnaire des pixmaps
	avec les données qui lui correspondent (en effet il est logique que seul l'avatr soit 
	au-courant des données qui lui vont) et mettre à vrai un booleen.
	De cette facon tous les autres avatars instanciés ne rerempilront pas le dictionnaire dèja
	garni, et pourront, à, chaque instant, acéder au pointeurs
	vers la pixmpas qui les interessent.
	
Gameplay :

 La gestion globale du gameplay est délégué le kernel à l'état PlayingGameState, dès que ce 
 dernier est instancié (ie dès que la prtie commence).
 Cet état gère les evènements captés par sa scène :
	- Traduit les entrées user par les actions spécifiques sur les avatars (ie : les footballers 
	"focusable") et sur le déroulement de la partie 
	(mise en pause, exit ...)
	- Decide à quelle équipe il donne le coup d'envoi (soit arbitrairement, soit en se basant sur
	une simulation de lancer de pièce d'arbitre).
	
	